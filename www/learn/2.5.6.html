<html>
	<head>
		<title></title>
	</head>
	<body>
		<p>
			Под выровненными деревьями мы будем понимать бинарные деревья, у которых все листья расположены на одном уровне. К выровненным деревьям относятся такие классы деревьев, как H-деревья, или деревья соседства, HB-деревья, или братские деревья, и др.</p>
		<p>
			<img align="left" alt="Подпись:  
Рис. 2.35. H-дерево
" height="130" hspace="12" src="file:///C:/Users/5394~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png" width="220" />Бинарное дерево называется <em>Н-деревом, </em>если все листья находятся на одном и том же уровне и каждая вершина с единственным потомком имеет правого соседа с двумя потомками. Н-дерево высоты hимеет, по крайней мере, (3/2)<sup>h</sup>листьев.</p>
		<p>
			Пример H-дерева приведен на рис. 2.35.</p>
		<p>
			Пусть H-дерево имеет по крайней мере две листья. Добавление новой вершины может быть произведено лишь на самом нижнем уровне, т. е. добавлена может быть только лист. При добавлении новой вершины у некоторой вершины может оказаться три потомка, а при удалении может появиться вершина без потомков на уровне выше уровня листьев. В обоих случаях восстановление структуры Н-дерева происходит с помощью алгоритма упрощения.</p>
		<p>
			<strong>Алгоритм упрощения (в вершине </strong><strong>n):</strong></p>
		<p>
			1. Если вершина <em>v</em>не имеет потомков, то удалить <em>v</em>и вызвать алгоритм упрощения для предка вершины <em>v.</em></p>
		<p>
			2. Если вершина <em>v</em>имеет в точности одного потомка, то возможны четыре случая:</p>
		<p>
			А. Вершина <em>v</em>имеет соседа <em>v&#39; </em>с одним потомком. В этом случае потомка вершины nперевешиваем к <em>v&#39;</em>, удаляем <em>v</em>и применяем алгоритм упрощения к предку вершины <em>v.</em></p>
		<p>
			Б. Вершина <em>v</em>не имеет соседей. В этом случае удаляем вершину <em>v</em>и делаем ее потомка новым корнем.</p>
		<p>
			В. Вершина <em>v</em>имеет левого соседа <em>v&#39; </em>с двумя потомками и не имеет правого соседа. Тогда перевесим правого потомка вершины <em>v&#39; </em>к вершине <em>v</em>и применяем алгоритм упрощения к вершине <em>v&#39;.</em></p>
		<p>
			Г. Вершина <em>v</em>имеет правого соседа с двумя потомками и либо не имеет левого соседа, либо имеет левого соседа с двумя потомками. В этом случае никакие преобразования не нужны.</p>
		<p>
			3. Если вершина <em>v</em>имеет точно двух потомков, то преобразования не нужны.</p>
		<p>
			4. Если вершина <em>v</em>имеет трех потомков, то возможны следующие два случая:</p>
		<p>
			А. Вершина <em>v</em>имеет соседа <em>v&#39; </em>с одним потомком. В этом случае перевесим одного потомка вершины <em>v</em>вершине <em>v&#39;.</em></p>
		<p>
			Б. Вершина <em>v</em>не имеет соседа с одним потомком. В этом случае образуем новую вершину <em>v&#39;, </em>единственный потомок которой был самым левым потомком вершины <em>v</em>. Если <em>v</em>была корнем дерева, то образуем новый корень с потомками <em>v</em>и <em>v&#39;. </em>Если вершина <em>v</em>имеет предка, то подвесим ее дополнительным потомком к предку вершины <em>v</em>и применим алгоритм упрощения к предку вершины <em>v.</em></p>
		<p>
			<img align="left" alt="Подпись:  
Рис.2.36. НВ-деревья
" height="304" hspace="12" src="file:///C:/Users/5394~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png" width="666" />Алгоритмы включения и исключения имеют трудоемкость O(log<sub>2</sub>n), где <em>п </em>&mdash; число листьев.</p>
		<p style="margin-left:1.1pt;">
			<strong>HB- деревья.</strong>Будем говорить, что вершина <img height="23" src="file:///C:/Users/5394~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" width="13" />&nbsp;есть <em>брат </em>вершины <em>х </em>и записывать <em><img height="23" src="file:///C:/Users/5394~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" width="13" />=</em><em>b</em><em>x</em> если <img height="23" src="file:///C:/Users/5394~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png" width="13" />&nbsp;и <em>х </em>имеют одного и того же предка. <em>Бинарное дерево называется НВ-деревом, если все листья находятся на одном и том же уровне и если каждая вершина х с одним потомком имеет брата </em><em>bх с двумя потомками.</em>Деревья, показанные на рис. 2.36,б и 2.36,в, представляют собой примеры братских деревьев, в отличие от дерева на рис. 2.36, <em>а.</em></p>
		<p style="margin-left:1.1pt;">
			Сравнение НВ - деревьев с Н-деревьями показывает, что, существуют Н-деревья, не являющиеся НВ - деревьями, и, наоборот, существует НВ- деревья, не являющимися Н-деревьями.</p>
		<p style="margin-left:2.4pt;">
			<em>НВ - дерево высоты </em><em>hимеет по крайней мере&nbsp;&nbsp; </em><em>Fib(</em><em>h+ 2)&nbsp;&nbsp; листьев.&nbsp;&nbsp; Здесь&nbsp;&nbsp; </em>Fib(h) <em>обозначает </em><em>h-</em><em>eчисло Фибоначчи: </em>Fib(1) = <em>Fib</em>(2) = 1, Fib<em>(</em><em>h+ </em>2) = Fib<em>(</em><em>h) + </em>Fib<em>(</em><em>h+ </em>1).</p>
		<p style="margin-left:.5pt;">
			Поскольку Fib(n) есть целое число, следующее за числом (a<sup>n</sup> - b<sup>n</sup>)/&Ouml;5, где a= (1 + &Ouml;5)/2,</p>
		<p style="margin-left:.5pt;">
			b= (1 - &Ouml;5)/2, то наименьшее число листьев в HB-дереве высоты <em>h</em>менее чем на единицу отличается от числа (a&times;2/&Ouml;5)a<sup>h</sup>= 1,170 &times;1,618<sup>h</sup>.</p>
		<p>
			Включение новой вершины, так же как и в случае H-деревьев, возможно лишь на уровне листьев. При этом возможно появление вершины с тремя потомками. Восстановление структуры НВ - дерева производится с помощью алгоритма упрощения, устроенного так, что его применение ограничено вершинами с тремя потомками, причем либо все три потомка &mdash; листья, либо по меньшей мере два из них сами имеют в точности по два потомка.</p>
		<p style="margin-left:17.65pt;">
			<strong>Алгоритм упрощения (в вершине </strong><strong><em>v):</em></strong></p>
		<p style="margin-left:2.05pt;">
			1. Если вершина <em>v</em>имеет в точности два потомка, то никакие преобразования не нужны.</p>
		<p style="margin-left:2.15pt;">
			2. Если вершина <em>v</em>имеет в точности трех потомков, то возможны два случая:</p>
		<p style="margin-left:2.05pt;">
			А. Вершина <em>v</em>не имеет братьев. Создадим вершине <em>v</em>брата <em>v</em><em><sup>&cent;</sup></em> и передадим ему в качестве потомка одного из потомков вершины <em>v</em>, имеющего, в свою очередь, двух потомков. Если вершина <em>v</em>была корнем, то образуем новый корень &mdash; предка вершин <em>v</em>и <em>v&#39;.</em></p>
		<p style="margin-left:2.15pt;">
			Б. Вершина <em>v</em>имеет брата <em>w. </em>Тогда, если <em>w</em>имеет точно одного потомка, то передадим ему одного подходящего потомка вершины <em>v. </em>Если же брат <em>w</em>имеет точно двух потомков, то создадим для <em>v</em>дополнительного (третьего) брата <em>v</em><em><sup>&cent;</sup></em>и передадим ему в качестве потомка одного из потомков вершины<em>v</em>, имеющего по крайней мере двух потомков. Затем применяем алгоритм упрощения к предку вершины <em>v.</em></p>
		<p style="margin-left:.25pt;">
			Нетрудно увидеть, что в случае Б., когда вершина <em>v</em>имеет в точности одного потомка, этот потомок должен быть либо листом, либо вершинойс двумя потомками. Вновь введенный потомок вершины <em>w</em>имеет в каждом случае брата с двумя потомками (если он не является листом).</p>
		<p style="margin-left:.1pt;">
			Удаление вершины есть в любом случае удаление листа, поэтому единственным осложнением может быть лишь появление внутренней вершины без потомков, т. е. листа на уровне выше уровня остальных листьев. В этом случае применяемся другой алгоритм упрощения.</p>
		<p style="margin-left:1.3pt;">
			<strong>Алгоритм упрощения при удалении(в вершине </strong><strong><em>v):</em></strong></p>
		<p style="margin-left:.85pt;">
			<em>1. </em>Если вершина <em>v</em> не имеет потомков, то удаляем ее и применяем алгоритм упрощения к предку вершины <em>v</em>.</p>
		<p style="margin-left:1.1pt;">
			2. Если вершина <em>v</em>имеет точно одного потомка, то либо вершина <em>v</em>не имеет братьев, либо имеет хотя бы одного брата.</p>
		<p style="margin-left:.95pt;">
			А. Вершина <em>v</em>не имеет братьев. Если при этом вершина <em>v</em>не имеет предка, т. е. является корнем, то удаляем вершину <em>v</em>и делаем единственного потомка вершины <em>v</em>новым корнем. В противном случае предок вершины <em>v</em>имеет брата &mdash; вершину <em>w</em>с двумя потомками &nbsp;<em>w&#39; </em>и <em>w&quot;. </em>Пусть <em>w<sup>&#39;</sup> </em>будет ближайшим соседом <em>v. </em>Тогда, если <em>w&quot; </em>имеет двух потомков,&nbsp; делаем вершину <em>w&#39; </em>братом <em>v</em>и применяем алгоритм упрощения снова к вершине ,<em>v. </em>Если же вершина <em>w&quot; </em>имеет одного потомка, то тогда вершина <em>w&#39; </em>должна иметь двух потомков; дадим вершине <em>w&quot; </em>в качестве дополнительного потомка вершины <em>w&#39; </em>и сделаем вершину <em>w&#39; </em>братом <em>v. </em>После этого применим алгоритм упрощения снова к вершине <em>v.</em></p>
		<p style="margin-left:1.3pt;">
			Б. Если вершина <em>v</em>имеет брата <em>w</em>, то преобразования нужны только в том случае, когда вершина <em>w</em>имеет только одного потомка. Мы сделаем потомка вершины <em>w</em>потомком вершины <em>v</em>, удалив вершину <em>w</em>и применив алгоритм упрощения к предку вершины <em>v.</em></p>
		<p style="margin-left:2.5pt;">
			Трудоемкость всех описанных алгоритмов равна О (logn), где <em>п &mdash; </em>число листьев.</p>
		<p style="margin-left:2.3pt;">
			<em>Бинарное дерево называется </em><em>HS-деревом, если справедливо следующее: все листья находятся на одном уровне, и, если вершина х имеет только одного потомка, то этот потомок есть либо лист, либо сам имеет двух потомков.</em></p>
		<p style="margin-left:2.75pt;">
			Очевидно, что каждое HB-дерево является также HS-деревом, но обратное неверно. Алгоритм включения нового слова в HS-дерево тот же, что и для HB-деревьев; алгоритм удаления несколько отличается в деталях.</p>
		<p>
			<strong>Бинарные деревья малой высоты. </strong>АВЛ-деревья, балансированные по весу деревья, H-деревья и HB-деревья могут рассматриваться как деревья с малой высотой, поскольку их высоты равны 1,44 log (n + 2), 1,071 log (n+1), 1,709 logn, 1,44log(n+1) соответственно. Но зачастую бывают нужны деревья как можно меньшей высоты. Докажем существование для любого e&gt; 0 балансированных выровненных бинарных деревьев с высотой (1+ e)log<em>n+ </em>1.</p>
		<p style="margin-left:.1pt;">
			Напомним, что вершина <em>v<sub>1</sub></em>называется непосредственно правым (непосредственно левым) соседом вершины <em>v<sub>0</sub></em>, если <em>v<sub>1 </sub></em>и&nbsp;<em>v<sub>0</sub></em>&mdash;вершины одного и того же уровня и вершина <em>v<sub>1</sub></em>появляется непосредственно справа (слева) от вершины <em>v<sub>0</sub></em>в графическом изображении дерева, содержащего <em>v<sub>0</sub> </em>и <em>v<sub>1</sub>&nbsp; </em>в качестве вершин.</p>
		<p style="margin-left:.7pt;">
			Для любого положительного целого <em>k</em>определим класс k-деревьев. Упорядоченное бинарное дерево называется <em>k-деревом, </em>если:</p>
		<p style="margin-left:1.1pt;">
			а) все листья располагаются на одном и том же уровне;</p>
		<p style="margin-left:.95pt;">
			б) вершина <em>v</em>с одним потомком имеет по крайней мере одного правого соседа и первые <em>k</em>правых соседей (или все правые соседи, если их число меньше <em>k) </em>вершины <em>v</em>имеют двух потомков.</p>
		<p style="margin-left:1.45pt;">
			Замечание. Требование иметь хотя бы одного соседа гарантирует отсутствие вырожденных деревьев с единственным листом.</p>
		<p style="margin-left:4.8pt;">
			Любое k-дерево есть k&#39;-дерево для <em>k&#39;</em><em>&pound;</em><em>k. </em>1-деревья &mdash;это в точности H-деревья. На рис. 2.37 изображены 1-дерево, 2-дерево и дерево, которое не является k-деревом ни для какого <em>k.</em></p>
		<p>
			<img align="left" alt="Подпись:  
Рис. 2.37. k-деревья
" height="213" hspace="12" src="file:///C:/Users/5394~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png" width="586" />Включение новой вершины происходит с помощью алгоритма k-включения.</p>
		<p>
			<strong>&nbsp;&nbsp; Алгоритм:</strong></p>
		<p>
			1. Если вершина <em>v</em>после включения новой вершины имеет точно двух потомков, то никакие преобразования не нужны.</p>
		<p>
			2. Пусть <em>v</em> имеет трех потомков, тогда:</p>
		<p>
			А. Хотя бы одна вершина из <em>k</em>левых или правых соседей вершины <em>v</em>имеет точно одного потомка. Берем одного из ближайших соседей с единственным потомком и вызываем процедуру ПЕРЕБРОС (<em>v&#39;</em>, <em>v).</em></p>
		<p>
			Б. Если ни одна вершина из <em>k</em>левых или правых соседей не имеет точно одного потомка, то создадим новую вершину <em>v&#39; </em>с левым потомком вершины <em>v</em>в качестве, ее единственного потомка. Возможны два подслучая: вершина <em>v</em>имеет или не имеет предка. Если не имеет, то создадим новую вершину <em>w</em>в качестве нового корня с потомками <em>v</em> и <em>v&#39;</em>. В противном случае подвесим <em>v&#39;</em> в качестве нового потомка к предку вершины <em>v</em>и применим алгоритм k-включения к вершине &mdash; предку <em>v.</em></p>
		<p>
			Процедура ПЕРЕБРОС (<em>v<sub>1</sub>, </em><em>v<sub>2</sub></em>), (вызываемая в случае 2А) определена для двух вершин <em>v<sub>1</sub> </em>и<em>v<sub>2</sub>, </em><em>v<sub>1 </sub></em><em>&sup1;</em><em>v<sub>2,</sub> </em>расположенных на одном и том же уровне. Вызов этой процедуры предполагает, что все вершины между <em>v<sub>1</sub> </em>и&nbsp; <em>v<sub>2 </sub></em>на том же уровне, что и <em>v<sub>1</sub> , </em>имеют двух потомков, <em>v<sub>1</sub>&nbsp; </em>имеет только одного потомка, вершина <em>v<sub>2</sub> &mdash; </em>трех.</p>
		<p style="margin-left:3.85pt;">
			Процедура ПЕРЕБРОС (<em>v<sub>1</sub>, </em><em>v<sub>2</sub>)</em>:</p>
		<p style="margin-left:19.7pt;">
			1. начало</p>
		<p style="margin-left:19.2pt;">
			2. если <em>v<sub>2</sub> -</em> правый сосед вершины <em>v<sub>1</sub></em>, то</p>
		<p style="margin-left:54.0pt;">
			3.<em>w:</em>= непосредственный правый сосед вершины <em>v<sub>1 </sub></em>;</p>
		<p style="margin-left:54.0pt;">
			4. иначе <em>w</em>:= непосредственный левый сосед вершины <em>v<sub>1</sub></em>;</p>
		<p style="margin-left:54.0pt;">
			5. <em>r</em>:= потомок вершины <em>w</em>, являющийся непосредственным соседом потомка вершины <em>v<sub>1</sub></em>;</p>
		<p style="margin-left:19.9pt;">
			6. сделать <em>r</em>дополнительным потомком вершины <em>v<sub>1 </sub></em>;</p>
		<p style="margin-left:19.2pt;">
			7. если <em>w</em><em>&sup1;</em><em>v<sub>2</sub></em>,то ПЕРЕБРОС(<em>w, </em><em>v<sub>2</sub></em>);</p>
		<p style="margin-left:18.85pt;">
			8. иначе стоп;</p>
		<p style="margin-left:18.95pt;">
			конец</p>
		<p>
			&nbsp;</p>
		<p>
			Удаление вершины есть удаление листа. Для восстановления структуры k-дерева используется алгоритм k-удаления (в вершине <em>v</em>).</p>
		<p>
			<strong>Алгоритм:</strong></p>
		<p>
			1. Если вершина <em>v</em>не имеет потомков, то удаляем и применяем алгоритм <em>k -</em>удаления к предку вершины <em>v.</em></p>
		<p>
			2. Если вершина <em>v</em>имеет одного потомка, то возможны два случая:</p>
		<p style="margin-left:18.0pt;">
			&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Одна вершина из <em>k</em>левых или правых соседей вершины <em>v</em>имеет одного потомка. Находим вершину <em>v&#39;</em> с единственным потомком, который является ближайшим соседом такого вида. Вызываем процедуру ПЕРЕБРОС (<em>v&#39;,</em> <em>v), </em>удаляем <em>v</em>и применяем алгоритм <em>k</em>-удаления к предку вершины <em>v.</em></p>
		<p style="margin-left:18.0pt;">
			&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ни один из <em>k</em>левых или правых соседей не имеет в точности одного потомка. Здесь возможен целый ряд вариантов:</p>
		<p style="margin-left:18.0pt;">
			-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Вершина <em>v</em>имеет по крайней мере одного правого соседа; преобразования не нужны.</p>
		<p style="margin-left:45.0pt;">
			- Вершина <em>v</em>не имеет правого соседа. Здесь также возможен ряд вариантов:</p>
		<p style="margin-left:63.0pt;">
			&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Если вершина <em>v</em>не имеет левого соседа, то удаляем <em>v</em>и берем единственного потомка вершины <em>v</em>в качестве нового корня.</p>
		<p style="margin-left:63.0pt;">
			&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Вершина <em>v</em>имеет по крайней мере одного правого и самое большее <em>k</em><em>&sup3; </em>1 левых соседей. Пусть <em>v&#39; </em>&mdash; непосредственный левый сосед вершины <em>v. </em>Сделаем правого потомка вершины <em>v&#39; </em>левым потомком вершины <em>v</em>, так что у <em>v</em>теперь два потомка.</p>
		<p style="margin-left:63.0pt;">
			&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Вершина &nbsp;<em>v</em>имеет по крайней мере <em>k+1 </em>левых соседей. Пусть <em>w</em>есть <em>k+</em>1-й левый сосед вершины <em>v</em>. Имеются две возможности:</p>
		<p style="margin-left:99.0pt;">
			Вершина <em>w</em>имеет только одного потомка. В этом случае вызываем процедуру ПЕРЕБРОС,(<em>w, </em><em>v</em>), удаляем вершину <em>v</em>и применяем алгоритм <em>k</em>-удаления к предку вершины <em>v.</em></p>
		<p style="margin-left:99.0pt;">
			Вершина <em>w</em>имеет двух потомков. Пусть <em>v&#39; </em>&mdash; непосредственный левый сосед вершины <em>v. </em>Сделаем правого потомка вершины <em>v&#39; </em>левым потомком вершины <em>v.</em></p>
		<p>
			Трудоемкость алгоритмов включения и удаления вершин для <em>k</em>-дерева высоты <em>h</em>пропорциональна его высоте <em>h</em>.</p>
		<p>
			<em>Для каждого </em><em>e &gt;0 существует такое </em><em>k</em>, <em>что класс </em><em>k-деревьев есть класс, сбалансированных бинарных деревьев высоты </em>&pound; (1 + e)log<em>п+</em>1, <em>где п &mdash;число листьев </em>[2,12].</p>
		<p>
			В заключение приведем высоты <em>k</em>-деревьев для малых значений <em>k. </em>Заметим, что для <em>k</em><em>&sup3;</em> 2 высоты меньше, чем высоты любого известного ранее класса cбалансированных бинарных деревьев (табл. 2.2).</p>
		<p>
			&nbsp;</p>
		<p align="right">
			Таблица&nbsp;&nbsp;&nbsp; 2.2</p>
		<table align="center" border="1" cellpadding="0" cellspacing="0">
			<tbody>
				<tr>
					<td style="width:66px;">
						<p align="center">
							<em>k</em></p>
					</td>
					<td style="width:256px;">
						<p align="center">
							(Высота <em>k</em>-дерева) - 1</p>
					</td>
					<td style="width:66px;">
						<p align="center">
							<em>k</em></p>
					</td>
					<td style="width:242px;">
						<p align="center">
							(Высота <em>k-</em>дерева<em>)</em> - 1</p>
					</td>
				</tr>
				<tr>
					<td style="width:66px;">
						<p align="center">
							1</p>
						<p align="center">
							2</p>
						<p align="center">
							3</p>
						<p align="center">
							4</p>
					</td>
					<td style="width:256px;">
						<p align="center">
							1,71 log n</p>
						<p align="center">
							1,36 log n</p>
						<p align="center">
							1,24 log n</p>
						<p align="center">
							1,18 log n</p>
					</td>
					<td style="width:66px;">
						<p align="center">
							5</p>
						<p align="center">
							9</p>
						<p align="center">
							99</p>
						<p align="center">
							&nbsp;</p>
					</td>
					<td style="width:242px;">
						<p align="center">
							1,14 log n</p>
						<p align="center">
							1,08 log n</p>
						<p align="center">
							1,01 logn</p>
					</td>
				</tr>
			</tbody>
		</table>
		<div style="clear:both;">
			&nbsp;</div>
		<p>
			&nbsp;</p>
		<p>
			Выровненные деревья дают наибольший возможный эффект при поиске. Однако известно, что вставка/удаление может потребовать полной перестройки всего дерева и, таким образом, трудоемкость операции в худшем случае составит 0(n).</p>
		<p>
			Сбалансированные деревья уступают выровненным деревьям по скорости поиска (менее чем в два раза), однако их преимущество состоит в том, что известны алгоритмы вставки и удаления узлов в сбалансированное дерево, которые сохраняют сбалансированность и в то же время при перестройке дерева затрагивают только конечное число узлов (см., например, [13]). Поэтому в подавляющем большинстве случаев АВЛ-дерево оказывается наилучшим вариантом представления дерева сортировки.</p>
	</body>
</html>
