<html>
	<head>
		<title></title>
	</head>
	<body>
		<p>
			Усовершенствованный метод&nbsp; представления бинарного дерева поиска, содержащего n узлов, с помощью массива, размер которого равен n&nbsp; единицам памяти вместо 2n-1,&nbsp; используется в методе пирамидальной сортировки [11].</p>
		<table cellpadding="0" cellspacing="0">
			<tbody>
				<tr>
					<td height="0">
						&nbsp;</td>
				</tr>
				<tr>
					<td>
						&nbsp;</td>
					<td>
						<img alt="" height="241" src="../images/24.png" width="647" /></td>
				</tr>
			</tbody>
		</table>
		<p>
			<br clear="ALL" />
			Узлы почти полного бинарного дерева могут быть пронумерованы так, что корню назначается номер 1, левому сыну - удвоенный номер его отца, а правому - удвоенный номер отца плюс единица. При такой схеме нумерации&nbsp; каждому&nbsp; узлу почти полного бинарного дерева поставлен в соответствие уникальный номер, который определяет позицию узла внутри дерева.&nbsp; Для представления почти полного бинарного дерева нет необходимости задавать связи между узлами дерева, так как узел с назначенным ему номером i является&nbsp; отцом узлов с номерами 2i и 2i+l (рис 2.4).</p>
		<p>
			&nbsp;Движение по дереву осуществляется функциями:</p>
		<p style="margin-left:45.35pt;">
			intLeft(inti) {return 2*i} Переход к сыновьему узлу 2i (левое поддерево) узла i</p>
		<p style="margin-left:45.0pt;">
			intRight(inti) {return 2*i+1} Переход к сыновьему узлу 2i+1 (правое поддерево) узла i</p>
		<p style="margin-left:45.0pt;">
			intParent(inti) {return i/2} Переход к родительскому узлу узла i</p>
		<p>
			Если добавить к такому представлению дерева условие: значение потомка не превосходит значения предка <strong>A[</strong>parent(i)] &gt;=A[i]&nbsp; и <strong>A[</strong>parent(i)] &gt;=A[i+1] (основное свойство кучи), то получим структуру, которая называется <em>двоичной кучей</em>. Эта структура используется в пирамидальной сортировке. Она позволяет эффективно организовать очередь с приоритетами. Встречаются алгоритмы, использующие сходные структуры данных (<em>биномиальные кучи, фибоначчиевы кучи</em>).</p>
		<p>
			Таким образом, наибольший элемент дерева (или любого поддерева) находится в корневой вершине дерева (этого поддерева).</p>
		<p>
			В дереве, составляющем кучу, все уровни (кроме, быть может, последнего) заполнены полностью. Поэтому высота этого дерева равна (log<sub>2</sub> n), где <em>п&mdash;</em>число элементов в куче. Перечислим основные операции над кучей:</p>
		<p>
			&bull; поддержание основного свойства, время работы составляет О(log<sub>2</sub> n);</p>
		<p>
			&bull; построение кучи из случайного массива, время работы О (n);</p>
		<p>
			&bull; сортировка массива без использования дополнительной памяти, время работы О<em>(п</em> log<sub>2</sub> n);</p>
		<p>
			&bull; операции взятия наибольшего и добавления элемента используются при моделировании очереди с приоритетами на базе кучи. Время работы обеих процедур составляет О (log<sub>2</sub> n).</p>
		<p>
			Рассмотрим основные из этих процедур.</p>
		<p>
			<img alt="" height="230" src="../images/25.png" width="657" /><br clear="ALL" />
			<strong>Функция сохранения основного свойства кучи </strong>(рис. 2.5). Идея проста: если основное свойство не выполнено для вершины <em>i, </em>то её следует поменять с большим из её детей и т. д., пока элемент <em>A[</em><em>i]</em> не &laquo;погрузится&raquo; до нужного места.</p>
		<p>
			Рис. 2.5а - начальное состояние кучи. В вершине <em>i =2</em> основное свойство нарушено. Чтобы восстановить его, необходимо поменять A[2] и А[4]. После этого (рис. 2.5б) основное свойство нарушается в вершине с индексом 4. Рекурсивный вызов процедуры сохранения свойств кучи восстанавливает основное свойство в вершине с индексом 4 путём перестановки A[4] &lt;--&gt; А[9] (рис. 2.5в). После этого основное свойство выполнено для всех вершин.</p>
		<p>
			<strong>Пример 2.1.</strong> Функция сохранения основного свойства кучи</p>
		<p>
			void SaveHeap(int A[], int i, int size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //а-массив, i-номер узла</p>
		<p>
			{</p>
		<p>
			&nbsp; int l=Left(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Левый сын узлаi</p>
		<p>
			&nbsp; int r=Right(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Правый сын узлаi</p>
		<p>
			&nbsp; int lagest=I, temp;&nbsp; // size = 10</p>
		<p>
			if (l&lt;=size &amp;&amp; A[l] &gt; A[i])&nbsp;&nbsp;&nbsp;</p>
		<p>
			&nbsp;&nbsp; largest=l;</p>
		<p>
			if (r&lt;=size &amp;&amp; A [r] &gt; A[largest])&nbsp;&nbsp;</p>
		<p>
			largest=r;</p>
		<p>
			if (largest !=i)</p>
		<p style="margin-left:25.45pt;">
			{</p>
		<p style="margin-left:25.45pt;">
			temp=A[i];</p>
		<p style="margin-left:25.45pt;">
			A[i]=A[largest];</p>
		<p style="margin-left:25.45pt;">
			A[largest]=temp;</p>
		<p style="margin-left:25.45pt;">
			SaveHeap(A, largest, size);</p>
		<p style="margin-left:25.45pt;">
			}</p>
		<p style="margin-left:25.45pt;">
			else</p>
		<p style="margin-left:25.45pt;">
			&nbsp;&nbsp; return</p>
		<p>
			}</p>
		<p>
			Работа процедуры SaveHeap показана на рис. 2.5. В переменную <strong>largest</strong>помещается индекс наибольшего из элементов A[i], A[Left(i)] и A[Right(i)]. Если largest=i, то элемент A[i] уже &laquo;погрузился&raquo; до нужного места, и работа процедуры закончена. Иначе процедура меняет местами A[i] и A[largest]<em>,</em> но, возможно, нарушает свойство кучи в вершине <strong>largest</strong> и рекурсивно вызывает себя для вершины <strong>largest,</strong> чтобы исправить возможные нарушения.</p>
		<p>
			<strong>Построение кучи.&nbsp; </strong>Пусть дан массив A[1..n], который мы хотим превратить в кучу, переставив его элементы. Для этого можно использовать процедуру SaveHeap,применяя её по очереди ко всем вершинам, начиная с нижних. Поскольку вершины с номерами [n/2]+1,...,n являются листьями, поддеревья с этими вершинами удовлетворяют основному свойству. Для каждой из оставшихся вершин, в порядке убывания индексов, мы применяем процедуру SaveHeap.Порядок обработки вершин гарантирует, что каждый раз условия вызова процедуры (выполнение основного свойства для поддеревьев) будут выполнены.</p>
		<p>
			Пример работы процедуры heapпоказан на рис. 2.6.</p>
		<p>
			<strong>Пример</strong><strong>2.2.</strong>Функция построения кучи.</p>
		<p>
			void CreateHeap (int A[], int size)</p>
		<p style="margin-left:9.35pt;">
			{</p>
		<p style="margin-left:9.35pt;">
			int i;</p>
		<p style="margin-left:9.35pt;">
			&nbsp;for (i=size/2; I &gt;=1;i--)</p>
		<p style="margin-left:9.35pt;">
			&nbsp;&nbsp; SaveHeap(A, I, size);</p>
		<table cellpadding="0" cellspacing="0">
			<tbody>
				<tr>
					<td height="0">
						&nbsp;</td>
				</tr>
				<tr>
					<td>
						&nbsp;</td>
					<td>
						<img alt="" height="443" src="../images/26.png" width="579" /></td>
				</tr>
			</tbody>
		</table>
		<p style="margin-left:9.35pt;">
			<br clear="ALL" />
			}</p>
		<p>
			Время работы процедурыCreateHeapне превышает0(n*log<sub>2</sub> n). Однако эту оценку можно улучшить при увеличении высоты дерева. В этом случае время работы процедуры CreateHeap составляет&nbsp;&nbsp;&nbsp;<br> <img src="../images/27.png" width="600" /><br><br></p><br><br><br><br><br><Br><br><br><br><br><br>
	</body>
</html>
