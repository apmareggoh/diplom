<html>
	<head>
		<title></title>
	</head>
	<body>
		<p>
			Рассмотрим способы автоматического выполнения операций над выражениями, представленными в виде бинарных деревьев. Операции выполняются над самими выражениями (символьные операции), а не над их значениями. Такие выражения можно складывать в символьной форме, перемножать, вычитать одно из другого, дифференцировать, интегрировать, сравнивать на эквивалентность и т. д. Некоторые из этих операций описаны в данном пункте, другие, например дифференцирование и интегрирование, описываются в [33].</p>
		<p>
			Теперь, когда мы уже умеем вычислять выражение, представленное бинарным деревом, рассмотрим операцию символьного сложения двух выражений. Предположим, например, что требуется сложить два выражения EXPR1 и EXPR2. Пусть Е1 и Е2 &mdash; указательные переменные, задающие корни бинарных деревьев для выражений EXPR1 и EXPR2 соответственно. Требуемое сложение легко выполнить путем создания новой корневой вершины для суммарного выражения и использования значений E1 и E2 в качестве значений соответственно левого и правого указателей этой вершины.</p>
		<p>
			Здесь P содержит адрес корневой вершины выражения EXPR1+EXPR2.</p>
		<p>
			Однако на практике бывает желательно, чтобы алгоритм сложения выполнял ряд упрощений получаемого выражения. Так, если складываемые выражения представляют собой константы, то необходимо создать новую вершину-константу, описывающую сумму этих констант. Более того, если одно из складываемых выражений равно нулю, то новой корневой вершины создавать не требуется. Аналогичные правила можно разработать и для других арифметических операций; их формулировки оставлены для упражнений.</p>
		<p>
			В качестве последнего примера рассмотрим проблему определения подобия двух выражений, представленных в виде бинарных деревьев. Два бинарных дерева, соответствующих арифметическим выражениям, называются подобными, если они совпадают для вершин всех типов, кроме тех вершин, которые описывают коммутативные операторы + и *. В этом последнем случае необходимо допускать вариант, когда левое поддерево первого дерева совпадает с правым поддеревом второго дерева и правое поддерево первого дерева совпадает с левым поддеревом второго дерева.</p>
	</body>
</html>
